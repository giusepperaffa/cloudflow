# ========================================
# Import Python Modules (Standard Library)
# ========================================
import os
import subprocess
import sys

# =======
# Classes
# =======
class PostprocessingManagerCls:
    """
    Class that handles the processing of the results
    generated by Pysa. As recommended in the Pysa
    documentation, the SAPP tool should be used to
    postprocess the Pysa-generated results. 
    """
    # === Constructor ===
    def __init__(self, folder_manager,
                 virtual_env='venv-sapp',
                 pysa_results_file='taint-output.json'):
        """
        Class constructor. Input arguments:
        1) folder_manager: Instance of the folder manager
        created by a dedicated tool class.
        2) virtual_env: String specifying the name of the
        SAPP (Pysa postprocessing tool) virtual environment.
        The class implement an automatic virtual environment
        switch. 
        """
        # Attribute initialization
        self.folder_manager = folder_manager
        self.virtual_env = virtual_env
        self.pysa_results_file = pysa_results_file

    # === Protected Method ===
    def _analyse_db(self):
        """
        Method that analyses all the invidual issues
        identified by Pysa and prints them out in a
        user-friendly way. 
        """
        self._copy_db_analysis_script()
        # The analysis of the SAPP database is conducted
        # on a per issue basis. The total number of issues
        # identified by Pysa is unknown a priori, so the
        # following while cycle continues until the last
        # Pysa issue is detected.
        issue_counter = 1
        while True:
            cmd = self._get_cmd_analyse_db(issue_counter)
            self._exec_cmd(cmd)
            if not self._process_db_analysis_results(): break
            # Increment issue counter ready for next analysis
            issue_counter += 1
        self._remove_db_analysis_script()

    # === Protected Method ===
    def _copy_db_analysis_script(self):
        """
        TBC
        """
        pass

    # === Protected Method ===
    def _dump_db_analysis_results(self):
        """
        TBC
        """
        pass

    # === Protected Method ===
    def _exec_cmd(self, cmd):
        """
        Method that executes a command passed as a string.
        """
        tool_execution = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE,
                                        stderr=subprocess.PIPE, universal_newlines=True)
        # Provide details on the command execution
        if tool_execution.returncode == 0:
            print(f'--- Successful execution of the command: {cmd} ---')
        else:
            print(f'--- Unsuccessful execution of the command: {cmd} ---')
            print(f'--- Return code: {str(tool_execution.returncode)} ---')
            print('--- Standard error: ---')
            print(f'{tool_execution.stderr}')

    # === Protected Method ===
    def _generate_db(self):
        """
        Method that maps the Pysa-generated results
        into an SQLite database via the SAPP tool.
        """
        print('--- Database generation with the SAPP tool is about to start ---')
        cmd = self._get_cmd_generate_db()
        self._exec_cmd(cmd)

    # === Protected Method ===
    def _get_cmd_analyse_db(self,
                            issue_number,
                            script='sapptoolpostprocessor.py'):
        """
        TBC
        """
        pass

    # === Protected Method ===
    def _get_cmd_generate_db(self):
        """
        Method that returns that string containing the
        command to be executed to generate a database
        with the SAPP tool starting from the results
        generated by Pysa.
        """
        # The full path of the Python executable of the SAPP
        # virtual enviroment is used to ensure that SAPP is
        # executed within the correct environment. This is a
        # way of implementing a switch between environments.
        cmd_list = [self._get_venv_python_path()]
        cmd_list.extend(['sapp', 'analyze', '.' + os.sep + 
                         os.path.join(os.path.basename(self.folder_manager.pysa_results_folder),
                                      self.pysa_results_file)])
        return ' '.join(cmd_list)

    # === Protected Method ===
    def _get_venv_python_path(self, python_path_info='bin/python3'):
        """
        Method that returns the full path of the Python
        executable within the virtual environment where
        the postprocessing tool has to run. The input
        parameter python_path_info specifies where the
        Python executable is within the environment. 
        NOTE: The code assumes that the analysis tool's
        virtual environment and the postprocessing tool
        virtual environment are stored within the same
        folder.         
        """
        # Note that sys.prefix returns the full path of
        # the virtual environment folder.  
        return os.path.join(os.path.dirname(sys.prefix),
                            self.virtual_env,
                            python_path_info)

    # === Protected Method ===
    def _process_db_analysis_results(self):
        """
        TBC
        """
        pass

    # === Protected Method ===
    def _remove_db_analysis_script(self):
        """
        TBC
        """
        pass

    # === Protected Method ===
    def _restore_cur_working_folder(self):
        """
        Method that restores the initial working folder.
        """
        os.chdir(self._initial_working_folder)
        print(f'--- Working folder restored to: {os.getcwd()} ---')

    # === Protected Method ===
    def _set_cur_working_folder(self):
        """
        Method that sets the current working folder
        to the CloudFlow analysis folder and saves
        the initial working folder in a protected
        instance variable.
        """
        self._initial_working_folder = os.getcwd()
        print(f'--- Current working folder: {self._initial_working_folder} ---')
        os.chdir(self.folders_manager.analysis_folder)
        print(f'--- New working folder: {os.getcwd()} ---')

    # === Method ===
    def postprocess_pysa_results(self):
        """
        Method that includes all the steps required
        to postprocess the Pysa-generated results.
        """
        self._set_cur_working_folder()
        self._generate_db()
        self._analyse_db()
        self._dump_db_analysis_results()
        self._restore_cur_working_folder()
